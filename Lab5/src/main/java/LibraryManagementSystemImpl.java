import entities.Book;
import entities.Borrow;
import entities.Card;
import queries.*;
import utils.DBInitializer;
import utils.DatabaseConnector;

import java.sql.*;
import java.util.List;

// import com.mysql.cj.protocol.Resultset;

public class LibraryManagementSystemImpl implements LibraryManagementSystem {

    private final DatabaseConnector connector;

    public LibraryManagementSystemImpl(DatabaseConnector connector) {
        this.connector = connector;
    }

    @Override
    public ApiResult storeBook(Book book) {
        Connection conn = connector.getConn();
        try {
            // check for exist
            PreparedStatement checkStmt = conn.prepareStatement(
                    "SELECT * FROM book WHERE category = ? AND title = ? AND press = ? AND publish_year = ? AND author = ?");
            checkStmt.setString(1, book.getCategory());
            checkStmt.setString(2, book.getTitle());
            checkStmt.setString(3, book.getPress());
            checkStmt.setInt(4, book.getPublishYear());
            checkStmt.setString(5, book.getAuthor());
            ResultSet rset = checkStmt.executeQuery();
            if (rset.next()) {
                throw new Exception("Book EXISTS. FAILED TO INSERT!");
            }

            // insert
            PreparedStatement insertStmt = conn.prepareStatement(
                    "INSERT INTO book (book_id, category, title, press, publish_year, author, price, stock) VALUES (0, ?, ?, ?, ?, ?, ?, ?)");
            insertStmt.setString(1, book.getCategory());
            insertStmt.setString(2, book.getTitle());
            insertStmt.setString(3, book.getPress());
            insertStmt.setInt(4, book.getPublishYear());
            insertStmt.setString(5, book.getAuthor());
            insertStmt.setDouble(6, book.getPrice());
            insertStmt.setInt(7, book.getStock());
            insertStmt.executeUpdate();

            // book_id generated by DB, should be queried and updated to "book"
            PreparedStatement queryStmt = conn.prepareStatement(
                    "SELECT book_id FROM book where category = ? AND title = ? AND press = ? AND publish_year = ? AND author = ?");
            queryStmt.setString(1, book.getCategory());
            queryStmt.setString(2, book.getTitle());
            queryStmt.setString(3, book.getPress());
            queryStmt.setInt(4, book.getPublishYear());
            queryStmt.setString(5, book.getAuthor());
            rset = queryStmt.executeQuery();
            if (rset.next()) {
                book.setBookId(rset.getInt("book_id"));
            }
            commit(conn);
        } catch (Exception e) {
            rollback(conn);
            return new ApiResult(false, e.getMessage());
        }
        return new ApiResult(true, null);
    }

    @Override
    public ApiResult incBookStock(int bookId, int deltaStock) {
        Connection conn = connector.getConn();
        try {
            // query
            String query = "SELECT stock FROM book WHERE book_id = ?";
            PreparedStatement queryStmt = conn.prepareStatement(query);
            queryStmt.setInt(1, bookId);
            ResultSet rset = queryStmt.executeQuery();

            // not found
            if (!rset.next()) {
                throw new Exception("The book does NOT exist!");
            }

            int currStock = rset.getInt("stock");
            int newStock = currStock + deltaStock;

            // not enough
            if (newStock < 0) {
                throw new Exception("INSUFFICIANT! \nCurrent: " + currStock + "\nTring to change by: " + deltaStock);
            }

            String update = "UPDATE book SET stock = ? WHERE book_id = ?";
            PreparedStatement updateStmt = conn.prepareStatement(update);
            updateStmt.setInt(1, newStock);
            updateStmt.setInt(2, bookId);
            updateStmt.executeUpdate();

            commit(conn);
        } catch (Exception e) {
            rollback(conn);
            return new ApiResult(false, e.getMessage());
        }
        return new ApiResult(true, null);
    }

    @Override
    public ApiResult storeBook(List<Book> books) {
        Connection conn = connector.getConn();
        try {
            String check = "SELECT * FROM book where category = ? AND title = ? AND press = ? AND publish_year = ? AND author = ?";
            String insert = "INSERT INTO book (book_id, category, title, press, publish_year, author, price, stock) VALUES (0, ?, ?, ?, ?, ?, ?, ?)";
            String query = "SELECT book_id FROM book where category = ? AND title = ? AND press = ? AND publish_year = ? AND author = ?";

            for (Book book : books) {
                // check for exist
                PreparedStatement checkStmt = conn.prepareStatement(check);
                checkStmt.setString(1, book.getCategory());
                checkStmt.setString(2, book.getTitle());
                checkStmt.setString(3, book.getPress());
                checkStmt.setInt(4, book.getPublishYear());
                checkStmt.setString(5, book.getAuthor());
                ResultSet rset = checkStmt.executeQuery();
                if (rset.next()) {
                    throw new Exception("Book EXISTS. FAILED TO INSERT!");
                }

                // insert
                PreparedStatement insertStmt = conn.prepareStatement(insert);
                insertStmt.setString(1, book.getCategory());
                insertStmt.setString(2, book.getTitle());
                insertStmt.setString(3, book.getPress());
                insertStmt.setInt(4, book.getPublishYear());
                insertStmt.setString(5, book.getAuthor());
                insertStmt.setDouble(6, book.getPrice());
                insertStmt.setInt(7, book.getStock());
                insertStmt.executeUpdate();

                // query
                PreparedStatement queryStmt = conn.prepareStatement(query);
                queryStmt.setString(1, book.getCategory());
                queryStmt.setString(2, book.getTitle());
                queryStmt.setString(3, book.getPress());
                queryStmt.setInt(4, book.getPublishYear());
                queryStmt.setString(5, book.getAuthor());
                rset = queryStmt.executeQuery();
                if (rset.next()) {
                    book.setBookId(rset.getInt("book_id"));
                }
            }
            commit(conn);
        } catch (Exception e) {
            rollback(conn);
            return new ApiResult(false, e.getMessage());
        }
        return new ApiResult(true, null);
    }

    @Override
    public ApiResult removeBook(int bookId) {
        Connection conn = connector.getConn();
        try {
            // check for exist
            String query = "SELECT * FROM book WHERE book_id = ?";
            PreparedStatement queryStmt = conn.prepareStatement(query);
            queryStmt.setInt(1, bookId);
            ResultSet rset = queryStmt.executeQuery();
            if (!rset.next()) {
                throw new Exception("The book does NOT exist!");
            }

            // check for unreturned
            String check = "SELECT * FROM borrow WHERE book_id = ? AND return_time = 0";
            PreparedStatement checkStmt = conn.prepareStatement(check);
            checkStmt.setInt(1, bookId);
            rset = checkStmt.executeQuery();
            if (rset.next()) {
                throw new Exception("There are books remain unreturned. REMOVE FAIED!");
            }

            // remove
            String remove = "DELETE FROM book WHERE book_id = ?";
            PreparedStatement removeStmt = conn.prepareStatement(remove);
            removeStmt.setInt(1, bookId);
            removeStmt.executeUpdate();

            commit(conn);
        } catch (Exception e) {
            rollback(conn);
            return new ApiResult(false, e.getMessage());
        }
        return new ApiResult(true, null);
    }

    @Override
    public ApiResult modifyBookInfo(Book book) {
        Connection conn = connector.getConn();
        try {
            // check for exist (book_id constrains)
            String query = "SELECT * FROM book WHERE book_id = ?;";
            PreparedStatement queryStmt = conn.prepareStatement(query);
            queryStmt.setInt(1, book.getBookId());
            ResultSet rset = queryStmt.executeQuery();
            if (!rset.next()) {
                throw new Exception("The book does NOT exist!");
            }

            // // check for stock (stock constrains)
            // int currStock = rset.getInt("stock");
            // if (currStock != book.getStock()) {
            // throw new Exception("Does NOT permit changing attribute 'stock'!");
            // }

            // check for newPrice
            if (book.getPrice() < 0) {
                throw new Exception("Does NOT permit 'price' lower than 0!");
            }

            String update = "UPDATE book SET category = ?, title = ?, press = ?, publish_year = ?, author = ?, price = ? WHERE book_id = ?";
            PreparedStatement updateStmt = conn.prepareStatement(update);
            updateStmt.setString(1, book.getCategory());
            updateStmt.setString(2, book.getTitle());
            updateStmt.setString(3, book.getPress());
            updateStmt.setInt(4, book.getPublishYear());
            updateStmt.setString(5, book.getAuthor());
            updateStmt.setDouble(6, book.getPrice());
            updateStmt.setInt(7, book.getBookId());
            updateStmt.executeUpdate();
            commit(conn);
        } catch (Exception e) {
            rollback(conn);
            return new ApiResult(false, e.getMessage());
        }
        return new ApiResult(true, null);
    }

    @Override
    public ApiResult queryBook(BookQueryConditions conditions) {
        Connection conn = connector.getConn();
        try {
            // query modes
            String baseQuery = "SELECT * FROM book WHERE";
            /*
             * It remains to be a bug if select with no conditions, in which case `WHERE`
             * should not exist.
             */
            if (conditions.getCategory() != null) {
                baseQuery += " category = ? and";
            }
            ;
            if (conditions.getTitle() != null) {
                baseQuery += " title LIKE ? and"; // blury
            }
            ;
            if (conditions.getPress() != null) {
                baseQuery += " press LIKE ? and"; // blury
            }
            ;
            if (conditions.getMinPublishYear() != null) {
                baseQuery += " publish_year >= ? and";
            }
            ;
            if (conditions.getMaxPublishYear() != null) {
                baseQuery += " publish_year <= ? and";
            }
            ;
            if (conditions.getAuthor() != null) {
                baseQuery += " author LIKE ? and"; // blury
            }
            ;
            if (conditions.getMinPrice() != null) {
                baseQuery += " price >= ? and";
            }
            ;
            if (conditions.getMaxPrice() != null) {
                baseQuery += " price <= ? and";
            }
            ;
            baseQuery = baseQuery.substring(0, baseQuery.length() - 4);

            // order
            if (conditions.getSortBy() != null) {
                baseQuery += " ORDER BY " + conditions.getSortBy().toString();
                if (conditions.getSortOrder() != null) {
                    baseQuery += " " + conditions.getSortOrder().toString();
                } else {
                    baseQuery += " ASC";
                }
                if (conditions.getSortBy() != Book.SortColumn.BOOK_ID) {
                    baseQuery += ", book_id ASC";
                }
            } else {
                baseQuery += " ORDER BY book_id ASC";
            }

            PreparedStatement queryStmt = conn.prepareStatement(baseQuery);
            int index = 1;
            if (conditions.getCategory() != null) {
                queryStmt.setString(index++, conditions.getCategory());
            }
            ; // exact
            if (conditions.getTitle() != null) {
                queryStmt.setString(index++, "%" + conditions.getTitle() + "%");
            }
            ; // blury
            if (conditions.getPress() != null) {
                queryStmt.setString(index++, "%" + conditions.getPress() + "%");
            }
            ; // blury
            if (conditions.getMinPublishYear() != null) {
                queryStmt.setInt(index++, conditions.getMinPublishYear());
            }
            ;
            if (conditions.getMaxPublishYear() != null) {
                queryStmt.setInt(index++, conditions.getMaxPublishYear());
            }
            ;
            if (conditions.getAuthor() != null) {
                queryStmt.setString(index++, "%" + conditions.getAuthor() + "%");
            }
            ; // blury
            if (conditions.getMinPrice() != null) {
                queryStmt.setDouble(index++, conditions.getMinPrice());
            }
            ;
            if (conditions.getMaxPrice() != null) {
                queryStmt.setDouble(index++, conditions.getMaxPrice());
            }
            ;
            ResultSet rset = queryStmt.executeQuery();

            List<Book> books = new java.util.ArrayList<>();
            while (rset.next()) {
                Book book = new Book();
                book.setBookId(rset.getInt("book_id"));
                book.setCategory(rset.getString("category"));
                book.setTitle(rset.getString("title"));
                book.setPress(rset.getString("press"));
                book.setPublishYear(rset.getInt("publish_year"));
                book.setAuthor(rset.getString("author"));
                book.setPrice(rset.getDouble("price"));
                book.setStock(rset.getInt("stock"));
                books.add(book);
            }
            commit(conn);
            return new ApiResult(true, new BookQueryResults(books));
        } catch (Exception e) {
            rollback(conn);
            return new ApiResult(false, e.getMessage());
        }
    }

    @Override
    public ApiResult borrowBook(Borrow borrow) {
        Connection conn = connector.getConn();
        try {
            // check for ID
            String checkCard = "SELECT * FROM card WHERE card_id = ?";
            PreparedStatement checkCardStmt = conn.prepareStatement(checkCard);
            checkCardStmt.setInt(1, borrow.getCardId());
            ResultSet rset = checkCardStmt.executeQuery();
            if (!rset.next()) {
                throw new Exception("The card does NOT exist!");
            }

            // check for exist and stock
            String checkBook = "SELECT * FROM book WHERE book_id = ? FOR UPDATE";
            // FOR UPDATE is used to lock the row for update
            PreparedStatement checkBookStmt = conn.prepareStatement(checkBook);
            checkBookStmt.setInt(1, borrow.getBookId());
            rset = checkBookStmt.executeQuery();
            if (!rset.next()) {
                throw new Exception("The book does NOT exist!");
            } else if (rset.getInt("stock") <= 0) {
                throw new Exception("The book is out of stock!");
            }

            // check for return
            String checkReturn = "SELECT * FROM borrow WHERE book_id = ? AND card_id = ? AND return_time = 0";
            PreparedStatement checkReturnStmt = conn.prepareStatement(checkReturn);
            checkReturnStmt.setInt(1, borrow.getBookId());
            checkReturnStmt.setInt(2, borrow.getCardId());
            rset = checkReturnStmt.executeQuery();
            if (rset.next()) {
                throw new Exception("The book has NOT been returned!");
            }

            // borrow
            String insert = "INSERT INTO borrow (book_id, card_id, borrow_time, return_time) VALUES (?, ?, ?, 0)";
            PreparedStatement insertStmt = conn.prepareStatement(insert);
            insertStmt.setInt(1, borrow.getBookId());
            insertStmt.setInt(2, borrow.getCardId());
            insertStmt.setLong(3, borrow.getBorrowTime());
            insertStmt.executeUpdate();

            // update stock
            String update = "UPDATE book SET stock = stock - 1 WHERE book_id = ?";
            PreparedStatement updateStmt = conn.prepareStatement(update);
            updateStmt.setInt(1, borrow.getBookId());
            updateStmt.executeUpdate();

            commit(conn);
        } catch (Exception e) {
            rollback(conn);
            return new ApiResult(false, e.getMessage());
        }
        return new ApiResult(true, null);
    }

    @Override
    public ApiResult returnBook(Borrow borrow) {
        Connection conn = connector.getConn();
        try {
            // check for ID
            String checkCard = "SELECT * FROM card WHERE card_id = ?";
            PreparedStatement checkCardStmt = conn.prepareStatement(checkCard);
            checkCardStmt.setInt(1, borrow.getCardId());
            ResultSet rset = checkCardStmt.executeQuery();
            if (!rset.next()) {
                throw new Exception("The card does NOT exist!");
            }

            // check for exist
            String checkBook = "SELECT * FROM book WHERE book_id = ?";
            PreparedStatement checkBookStmt = conn.prepareStatement(checkBook);
            checkBookStmt.setInt(1, borrow.getBookId());
            rset = checkBookStmt.executeQuery();
            if (!rset.next()) {
                throw new Exception("The book does NOT exist!");
            }

            // check for return
            String checkReturn = "SELECT * FROM borrow WHERE book_id = ? AND card_id = ? AND return_time = 0";
            PreparedStatement checkReturnStmt = conn.prepareStatement(checkReturn);
            checkReturnStmt.setInt(1, borrow.getBookId());
            checkReturnStmt.setInt(2, borrow.getCardId());
            rset = checkReturnStmt.executeQuery();
            if (!rset.next()) {
                throw new Exception("Record NOT found !");
            }
            // check for return time
            if (rset.getLong("borrow_time") >= borrow.getReturnTime()) {
                throw new Exception("The return time is earlier than or equal to the borrow time!");
            }

            // return
            String updateBorrow = "UPDATE borrow SET return_time = ? WHERE book_id = ? AND card_id = ? AND return_time = 0";
            PreparedStatement updateBorrowStmt = conn.prepareStatement(updateBorrow);
            updateBorrowStmt.setLong(1, borrow.getReturnTime());
            updateBorrowStmt.setInt(2, borrow.getBookId());
            updateBorrowStmt.setInt(3, borrow.getCardId());
            updateBorrowStmt.executeUpdate();

            // update stock
            String updateStock = "UPDATE book SET stock = stock + 1 WHERE book_id = ?";
            PreparedStatement updateStockStmt = conn.prepareStatement(updateStock);
            updateStockStmt.setInt(1, borrow.getBookId());
            updateStockStmt.executeUpdate();

            commit(conn);
        } catch (Exception e) {
            rollback(conn);
            return new ApiResult(false, e.getMessage());
        }
        return new ApiResult(true, null);
    }

    @Override
    public ApiResult showBorrowHistory(int cardId) {
        Connection conn = connector.getConn();
        try {
            // check for ID
            String checkCard = "SELECT * FROM card WHERE card_id = ?";
            PreparedStatement checkCardStmt = conn.prepareStatement(checkCard);
            checkCardStmt.setInt(1, cardId);
            ResultSet rset = checkCardStmt.executeQuery();
            if (!rset.next()) {
                throw new Exception("The card does NOT exist!");
            }

            // query
            String queryBorrow = "SELECT * FROM borrow WHERE card_id = ? ORDER BY borrow_time DESC, book_id ASC";
            String queryBook = "SELECT * FROM book WHERE book_id = ?";
            PreparedStatement queryBorrowStmt = conn.prepareStatement(queryBorrow);
            PreparedStatement queryBookStmt = conn.prepareStatement(queryBook);
            queryBorrowStmt.setInt(1, cardId);
            rset = queryBorrowStmt.executeQuery();
            List<BorrowHistories.Item> items = new java.util.ArrayList<>();
            while (rset.next()) {
                Borrow borrow = new Borrow(rset.getInt("book_id"), rset.getInt("card_id"));
                borrow.setBorrowTime(rset.getLong("borrow_time"));
                borrow.setReturnTime(rset.getLong("return_time"));
                queryBookStmt.setInt(1, borrow.getBookId());
                ResultSet rset1 = queryBookStmt.executeQuery();
                if (rset1.next()) {
                    Book book = new Book();
                    book.setBookId(rset1.getInt("book_id"));
                    book.setCategory(rset1.getString("category"));
                    book.setTitle(rset1.getString("title"));
                    book.setPress(rset1.getString("press"));
                    book.setPublishYear(rset1.getInt("publish_year"));
                    book.setAuthor(rset1.getString("author"));
                    book.setPrice(rset1.getDouble("price"));
                    book.setStock(rset1.getInt("stock"));
                    items.add(new BorrowHistories.Item(cardId, book, borrow));
                } else {
                    throw new Exception("The book does NOT exist!");
                }
            }
            BorrowHistories histories = new BorrowHistories(items);
            commit(conn);
            return new ApiResult(true, histories);
        } catch (Exception e) {
            rollback(conn);
            return new ApiResult(false, e.getMessage());
        }
    }

    @Override
    public ApiResult registerCard(Card card) {
        Connection conn = connector.getConn();
        try {
            // check for exist
            String check = "SELECT * FROM card WHERE name = ? AND department = ? AND type = ?";
            PreparedStatement checkStmt = conn.prepareStatement(check);
            checkStmt.setString(1, card.getName());
            checkStmt.setString(2, card.getDepartment());
            checkStmt.setString(3, card.getType().getStr());
            ResultSet rset = checkStmt.executeQuery();
            if (rset.next()) {
                throw new Exception("The card already exists!");
            }

            // insert
            String insert = "INSERT INTO card (card_id, name, department, type) VALUES (0, ?, ?, ?)";
            PreparedStatement insertStmt = conn.prepareStatement(insert);
            insertStmt.setString(1, card.getName());
            insertStmt.setString(2, card.getDepartment());
            insertStmt.setString(3, card.getType().getStr());
            insertStmt.executeUpdate();

            // card_id generated by DB, should be queried and updated to "card"
            String query = "SELECT card_id FROM card WHERE name = ? AND department = ? AND type = ?";
            PreparedStatement queryStmt = conn.prepareStatement(query);
            queryStmt.setString(1, card.getName());
            queryStmt.setString(2, card.getDepartment());
            queryStmt.setString(3, card.getType().getStr());
            rset = queryStmt.executeQuery();
            if (rset.next()) {
                card.setCardId(rset.getInt("card_id"));
            }

            commit(conn);
        } catch (Exception e) {
            rollback(conn);
            return new ApiResult(false, e.getMessage());
        }
        return new ApiResult(true, null);
    }

    @Override
    public ApiResult removeCard(int cardId) {
        Connection conn = connector.getConn();
        try {
            // check for exist
            String check = "SELECT * FROM card WHERE card_id = ?";
            PreparedStatement checkStmt = conn.prepareStatement(check);
            checkStmt.setInt(1, cardId);
            ResultSet rset = checkStmt.executeQuery();
            if (!rset.next()) {
                throw new Exception("The card does NOT exist!");
            }

            // check for unreturned
            String checkReturn = "SELECT * FROM borrow WHERE card_id = ? AND return_time = 0";
            PreparedStatement checkReturnStmt = conn.prepareStatement(checkReturn);
            checkReturnStmt.setInt(1, cardId);
            rset = checkReturnStmt.executeQuery();
            if (rset.next()) {
                throw new Exception("There are books remain unreturned. REMOVE FAIED!");
            }

            // remove
            String remove = "DELETE FROM card WHERE card_id = ?";
            PreparedStatement removeStmt = conn.prepareStatement(remove);
            removeStmt.setInt(1, cardId);
            removeStmt.executeUpdate();

            commit(conn);
        } catch (Exception e) {
            rollback(conn);
            return new ApiResult(false, e.getMessage());
        }
        return new ApiResult(true, null);
    }

    @Override
    public ApiResult showCards() {
        Connection conn = connector.getConn();
        try {
            // query
            String query = "SELECT * FROM card ORDER BY card_id ASC";
            PreparedStatement queryStmt = conn.prepareStatement(query);
            ResultSet rset = queryStmt.executeQuery();
            List<Card> cards = new java.util.ArrayList<>();
            while (rset.next()) {
                Card card = new Card();
                card.setCardId(rset.getInt("card_id"));
                card.setName(rset.getString("name"));
                card.setDepartment(rset.getString("department"));
                card.setType(Card.CardType.values(rset.getString("type")));
                cards.add(card);
            }
            CardList cardList = new CardList(cards);
            commit(conn);
            return new ApiResult(true, cardList);
        } catch (Exception e) {
            rollback(conn);
            return new ApiResult(false, e.getMessage());
        }
    }

    @Override
    public ApiResult resetDatabase() {
        Connection conn = connector.getConn();
        try {
            Statement stmt = conn.createStatement();
            DBInitializer initializer = connector.getConf().getType().getDbInitializer();
            stmt.addBatch(initializer.sqlDropBorrow());
            stmt.addBatch(initializer.sqlDropBook());
            stmt.addBatch(initializer.sqlDropCard());
            stmt.addBatch(initializer.sqlCreateCard());
            stmt.addBatch(initializer.sqlCreateBook());
            stmt.addBatch(initializer.sqlCreateBorrow());
            stmt.executeBatch();
            commit(conn);
        } catch (Exception e) {
            rollback(conn);
            return new ApiResult(false, e.getMessage());
        }
        return new ApiResult(true, null);
    }

    private void rollback(Connection conn) {
        try {
            conn.rollback();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void commit(Connection conn) {
        try {
            conn.commit();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
